package chapter9.moreOnDelegation

import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty

// https://kotlinlang.org/docs/delegation.html
// https://kotlinlang.org/docs/delegated-properties.html

// A class Derived can implement an interface Base by delegating all of
// its public members to a specific object.
interface Base {
    fun print()
}

class BaseImpl(val x: Int): Base {
    override fun print() {
        println(x)
    }
}

// b will be stored internally in objects of Derived.
// The compiler will generate all the methods of Base that forward
// to b.
class Derived(b: Base): Base by b

val b = BaseImpl(10)
Derived(b).print()



// Lazy properties

// By default, the evaluation of lazy properties is synchronized: the value is computed only in one
// thread, and all threads will see the same value. If the synchronization of initialization
// delegate is not required, so that multiple threads can execute it simultaneously, pass
// LazyThreadSafetyMode.PUBLICATION as a parameter to the lazy() function.

// And if you're sure that the initialization will always happen on the same thread as the one
// where you use the property, you can use LazyThreadSafetyMode.NONE: it doesn't incur any
// thread-safety guarantees and the related overhead.
val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}

println(lazyValue)
println(lazyValue)
//computed!
//Hello
//Hello


// Delegating to another property

// To delegate a property to another property, use the proper :: qualifier in the delegate name,
// for example, this::delegate or MyClass::delegate.
//var topLevelInt: Int = 0
//
//class ClassWithDelegate(val anotherClassInt: Int)
//
//class MyClass(var memberInt: Int, val anotherClassInstance: ClassWithDelegate) {
//    var delegatedToMember: Int by this::memberInt
//    var delegatedToTopLevel: Int by ::topLevelInt
//
//    val delegatedToAnotherClass: Int by anotherClassInstance::anotherClassInt
//}
//
//var MyClass.extDelegated: Int by ::topLevelInt


// This may be useful, for example, when you want to rename a property in a backward-compatible
// way: you introduce a new property, annotate the old one with the @Deprecated annotation, and
// delegate its implementation.
class MyClass {
    var newName: Int = 0
    @Deprecated("Use 'newName' instead", ReplaceWith("newName"))
    var oldName: Int by this::newName
}

val myClass = MyClass()
// Notification: 'oldName: Int' is deprecated.
// Use 'newName' instead
myClass.oldName = 42
println(myClass.newName) // 42


// Create delegates as anonymous objects without creating new classes using the interfaces
// ReadOnlyProperty and ReadWriteProperty.
fun resourceDelegate(): ReadWriteProperty<Any?, Int> =
    object : ReadWriteProperty<Any?, Int> {
        var curValue = 0
        override fun getValue(thisRef: Any?, property: KProperty<*>): Int = curValue
        override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
            curValue = value
        }
    }

val readOnly: Int by resourceDelegate()  // ReadWriteProperty as val
var readWrite: Int by resourceDelegate()


// Translagion rules
// Under the hood for every delegated property the Kotlin compiler generates an auxiliary property
// and delegates to it.
//class C {
//    var prop: Type by MyDelegate()
//}
//
//// This code is generated by the compiler instead:
//class C {
//    private val prop$delegate = MyDelegate()
//    var prop: Type
//        get() = prop$delegate.getValue(this, this::prop)
//        set(value: Type) = prop$delegate.setValue(this, this::prop, value)
//}
